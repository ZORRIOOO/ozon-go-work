// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i homework/cart/internal/pkg/cart/service/delete-cart.CartRepository -o repository-mock.go -n CartRepositoryMock -p mock

import (
	"homework/cart/internal/pkg/cart/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// CartRepositoryMock implements mm_delete_cart.CartRepository
type CartRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddItem          func(params model.CartItem) (cp1 *model.CartItem, err error)
	funcAddItemOrigin    string
	inspectFuncAddItem   func(params model.CartItem)
	afterAddItemCounter  uint64
	beforeAddItemCounter uint64
	AddItemMock          mCartRepositoryMockAddItem

	funcDeleteItem          func(params model.DeleteCartParameters) (cp1 *model.CartItem, err error)
	funcDeleteItemOrigin    string
	inspectFuncDeleteItem   func(params model.DeleteCartParameters)
	afterDeleteItemCounter  uint64
	beforeDeleteItemCounter uint64
	DeleteItemMock          mCartRepositoryMockDeleteItem

	funcDeleteItemsByUser          func(userId model.UserId) (up1 *model.UserId, err error)
	funcDeleteItemsByUserOrigin    string
	inspectFuncDeleteItemsByUser   func(userId model.UserId)
	afterDeleteItemsByUserCounter  uint64
	beforeDeleteItemsByUserCounter uint64
	DeleteItemsByUserMock          mCartRepositoryMockDeleteItemsByUser

	funcGetItemsByUser          func(userId model.UserId) (ca1 []model.CartItem, err error)
	funcGetItemsByUserOrigin    string
	inspectFuncGetItemsByUser   func(userId model.UserId)
	afterGetItemsByUserCounter  uint64
	beforeGetItemsByUserCounter uint64
	GetItemsByUserMock          mCartRepositoryMockGetItemsByUser
}

// NewCartRepositoryMock returns a mock for mm_delete_cart.CartRepository
func NewCartRepositoryMock(t minimock.Tester) *CartRepositoryMock {
	m := &CartRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddItemMock = mCartRepositoryMockAddItem{mock: m}
	m.AddItemMock.callArgs = []*CartRepositoryMockAddItemParams{}

	m.DeleteItemMock = mCartRepositoryMockDeleteItem{mock: m}
	m.DeleteItemMock.callArgs = []*CartRepositoryMockDeleteItemParams{}

	m.DeleteItemsByUserMock = mCartRepositoryMockDeleteItemsByUser{mock: m}
	m.DeleteItemsByUserMock.callArgs = []*CartRepositoryMockDeleteItemsByUserParams{}

	m.GetItemsByUserMock = mCartRepositoryMockGetItemsByUser{mock: m}
	m.GetItemsByUserMock.callArgs = []*CartRepositoryMockGetItemsByUserParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mCartRepositoryMockAddItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockAddItemExpectation
	expectations       []*CartRepositoryMockAddItemExpectation

	callArgs []*CartRepositoryMockAddItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockAddItemExpectation specifies expectation struct of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockAddItemParams
	paramPtrs          *CartRepositoryMockAddItemParamPtrs
	expectationOrigins CartRepositoryMockAddItemExpectationOrigins
	results            *CartRepositoryMockAddItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockAddItemParams contains parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParams struct {
	params model.CartItem
}

// CartRepositoryMockAddItemParamPtrs contains pointers to parameters of the CartRepository.AddItem
type CartRepositoryMockAddItemParamPtrs struct {
	params *model.CartItem
}

// CartRepositoryMockAddItemResults contains results of the CartRepository.AddItem
type CartRepositoryMockAddItemResults struct {
	cp1 *model.CartItem
	err error
}

// CartRepositoryMockAddItemOrigins contains origins of expectations of the CartRepository.AddItem
type CartRepositoryMockAddItemExpectationOrigins struct {
	origin       string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddItem *mCartRepositoryMockAddItem) Optional() *mCartRepositoryMockAddItem {
	mmAddItem.optional = true
	return mmAddItem
}

// Expect sets up expected params for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Expect(params model.CartItem) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.paramPtrs != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by ExpectParams functions")
	}

	mmAddItem.defaultExpectation.params = &CartRepositoryMockAddItemParams{params}
	mmAddItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddItem.expectations {
		if minimock.Equal(e.params, mmAddItem.defaultExpectation.params) {
			mmAddItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddItem.defaultExpectation.params)
		}
	}

	return mmAddItem
}

// ExpectParamsParam1 sets up expected param params for CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) ExpectParamsParam1(params model.CartItem) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{}
	}

	if mmAddItem.defaultExpectation.params != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Expect")
	}

	if mmAddItem.defaultExpectation.paramPtrs == nil {
		mmAddItem.defaultExpectation.paramPtrs = &CartRepositoryMockAddItemParamPtrs{}
	}
	mmAddItem.defaultExpectation.paramPtrs.params = &params
	mmAddItem.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmAddItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Inspect(f func(params model.CartItem)) *mCartRepositoryMockAddItem {
	if mmAddItem.mock.inspectFuncAddItem != nil {
		mmAddItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.AddItem")
	}

	mmAddItem.mock.inspectFuncAddItem = f

	return mmAddItem
}

// Return sets up results that will be returned by CartRepository.AddItem
func (mmAddItem *mCartRepositoryMockAddItem) Return(cp1 *model.CartItem, err error) *CartRepositoryMock {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	if mmAddItem.defaultExpectation == nil {
		mmAddItem.defaultExpectation = &CartRepositoryMockAddItemExpectation{mock: mmAddItem.mock}
	}
	mmAddItem.defaultExpectation.results = &CartRepositoryMockAddItemResults{cp1, err}
	mmAddItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// Set uses given function f to mock the CartRepository.AddItem method
func (mmAddItem *mCartRepositoryMockAddItem) Set(f func(params model.CartItem) (cp1 *model.CartItem, err error)) *CartRepositoryMock {
	if mmAddItem.defaultExpectation != nil {
		mmAddItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.AddItem method")
	}

	if len(mmAddItem.expectations) > 0 {
		mmAddItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.AddItem method")
	}

	mmAddItem.mock.funcAddItem = f
	mmAddItem.mock.funcAddItemOrigin = minimock.CallerInfo(1)
	return mmAddItem.mock
}

// When sets expectation for the CartRepository.AddItem which will trigger the result defined by the following
// Then helper
func (mmAddItem *mCartRepositoryMockAddItem) When(params model.CartItem) *CartRepositoryMockAddItemExpectation {
	if mmAddItem.mock.funcAddItem != nil {
		mmAddItem.mock.t.Fatalf("CartRepositoryMock.AddItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockAddItemExpectation{
		mock:               mmAddItem.mock,
		params:             &CartRepositoryMockAddItemParams{params},
		expectationOrigins: CartRepositoryMockAddItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddItem.expectations = append(mmAddItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.AddItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockAddItemExpectation) Then(cp1 *model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockAddItemResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.AddItem should be invoked
func (mmAddItem *mCartRepositoryMockAddItem) Times(n uint64) *mCartRepositoryMockAddItem {
	if n == 0 {
		mmAddItem.mock.t.Fatalf("Times of CartRepositoryMock.AddItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddItem.expectedInvocations, n)
	mmAddItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddItem
}

func (mmAddItem *mCartRepositoryMockAddItem) invocationsDone() bool {
	if len(mmAddItem.expectations) == 0 && mmAddItem.defaultExpectation == nil && mmAddItem.mock.funcAddItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddItem.mock.afterAddItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddItem implements mm_delete_cart.CartRepository
func (mmAddItem *CartRepositoryMock) AddItem(params model.CartItem) (cp1 *model.CartItem, err error) {
	mm_atomic.AddUint64(&mmAddItem.beforeAddItemCounter, 1)
	defer mm_atomic.AddUint64(&mmAddItem.afterAddItemCounter, 1)

	mmAddItem.t.Helper()

	if mmAddItem.inspectFuncAddItem != nil {
		mmAddItem.inspectFuncAddItem(params)
	}

	mm_params := CartRepositoryMockAddItemParams{params}

	// Record call args
	mmAddItem.AddItemMock.mutex.Lock()
	mmAddItem.AddItemMock.callArgs = append(mmAddItem.AddItemMock.callArgs, &mm_params)
	mmAddItem.AddItemMock.mutex.Unlock()

	for _, e := range mmAddItem.AddItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmAddItem.AddItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddItem.AddItemMock.defaultExpectation.Counter, 1)
		mm_want := mmAddItem.AddItemMock.defaultExpectation.params
		mm_want_ptrs := mmAddItem.AddItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockAddItemParams{params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddItem.t.Errorf("CartRepositoryMock.AddItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddItem.AddItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAddItem.AddItemMock.defaultExpectation.results
		if mm_results == nil {
			mmAddItem.t.Fatal("No results are set for the CartRepositoryMock.AddItem")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmAddItem.funcAddItem != nil {
		return mmAddItem.funcAddItem(params)
	}
	mmAddItem.t.Fatalf("Unexpected call to CartRepositoryMock.AddItem. %v", params)
	return
}

// AddItemAfterCounter returns a count of finished CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.afterAddItemCounter)
}

// AddItemBeforeCounter returns a count of CartRepositoryMock.AddItem invocations
func (mmAddItem *CartRepositoryMock) AddItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddItem.beforeAddItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.AddItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddItem *mCartRepositoryMockAddItem) Calls() []*CartRepositoryMockAddItemParams {
	mmAddItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockAddItemParams, len(mmAddItem.callArgs))
	copy(argCopy, mmAddItem.callArgs)

	mmAddItem.mutex.RUnlock()

	return argCopy
}

// MinimockAddItemDone returns true if the count of the AddItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockAddItemDone() bool {
	if m.AddItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddItemMock.invocationsDone()
}

// MinimockAddItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockAddItemInspect() {
	for _, e := range m.AddItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddItemCounter := mm_atomic.LoadUint64(&m.afterAddItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddItemMock.defaultExpectation != nil && afterAddItemCounter < 1 {
		if m.AddItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.AddItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s with params: %#v", m.AddItemMock.defaultExpectation.expectationOrigins.origin, *m.AddItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddItem != nil && afterAddItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.AddItem at\n%s", m.funcAddItemOrigin)
	}

	if !m.AddItemMock.invocationsDone() && afterAddItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.AddItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddItemMock.expectedInvocations), m.AddItemMock.expectedInvocationsOrigin, afterAddItemCounter)
	}
}

type mCartRepositoryMockDeleteItem struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteItemExpectation
	expectations       []*CartRepositoryMockDeleteItemExpectation

	callArgs []*CartRepositoryMockDeleteItemParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteItemExpectation specifies expectation struct of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteItemParams
	paramPtrs          *CartRepositoryMockDeleteItemParamPtrs
	expectationOrigins CartRepositoryMockDeleteItemExpectationOrigins
	results            *CartRepositoryMockDeleteItemResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteItemParams contains parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParams struct {
	params model.DeleteCartParameters
}

// CartRepositoryMockDeleteItemParamPtrs contains pointers to parameters of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemParamPtrs struct {
	params *model.DeleteCartParameters
}

// CartRepositoryMockDeleteItemResults contains results of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemResults struct {
	cp1 *model.CartItem
	err error
}

// CartRepositoryMockDeleteItemOrigins contains origins of expectations of the CartRepository.DeleteItem
type CartRepositoryMockDeleteItemExpectationOrigins struct {
	origin       string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Optional() *mCartRepositoryMockDeleteItem {
	mmDeleteItem.optional = true
	return mmDeleteItem
}

// Expect sets up expected params for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Expect(params model.DeleteCartParameters) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.paramPtrs != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by ExpectParams functions")
	}

	mmDeleteItem.defaultExpectation.params = &CartRepositoryMockDeleteItemParams{params}
	mmDeleteItem.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItem.expectations {
		if minimock.Equal(e.params, mmDeleteItem.defaultExpectation.params) {
			mmDeleteItem.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItem.defaultExpectation.params)
		}
	}

	return mmDeleteItem
}

// ExpectParamsParam1 sets up expected param params for CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) ExpectParamsParam1(params model.DeleteCartParameters) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{}
	}

	if mmDeleteItem.defaultExpectation.params != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Expect")
	}

	if mmDeleteItem.defaultExpectation.paramPtrs == nil {
		mmDeleteItem.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemParamPtrs{}
	}
	mmDeleteItem.defaultExpectation.paramPtrs.params = &params
	mmDeleteItem.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmDeleteItem
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Inspect(f func(params model.DeleteCartParameters)) *mCartRepositoryMockDeleteItem {
	if mmDeleteItem.mock.inspectFuncDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItem")
	}

	mmDeleteItem.mock.inspectFuncDeleteItem = f

	return mmDeleteItem
}

// Return sets up results that will be returned by CartRepository.DeleteItem
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Return(cp1 *model.CartItem, err error) *CartRepositoryMock {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	if mmDeleteItem.defaultExpectation == nil {
		mmDeleteItem.defaultExpectation = &CartRepositoryMockDeleteItemExpectation{mock: mmDeleteItem.mock}
	}
	mmDeleteItem.defaultExpectation.results = &CartRepositoryMockDeleteItemResults{cp1, err}
	mmDeleteItem.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// Set uses given function f to mock the CartRepository.DeleteItem method
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Set(f func(params model.DeleteCartParameters) (cp1 *model.CartItem, err error)) *CartRepositoryMock {
	if mmDeleteItem.defaultExpectation != nil {
		mmDeleteItem.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteItem method")
	}

	if len(mmDeleteItem.expectations) > 0 {
		mmDeleteItem.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteItem method")
	}

	mmDeleteItem.mock.funcDeleteItem = f
	mmDeleteItem.mock.funcDeleteItemOrigin = minimock.CallerInfo(1)
	return mmDeleteItem.mock
}

// When sets expectation for the CartRepository.DeleteItem which will trigger the result defined by the following
// Then helper
func (mmDeleteItem *mCartRepositoryMockDeleteItem) When(params model.DeleteCartParameters) *CartRepositoryMockDeleteItemExpectation {
	if mmDeleteItem.mock.funcDeleteItem != nil {
		mmDeleteItem.mock.t.Fatalf("CartRepositoryMock.DeleteItem mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteItemExpectation{
		mock:               mmDeleteItem.mock,
		params:             &CartRepositoryMockDeleteItemParams{params},
		expectationOrigins: CartRepositoryMockDeleteItemExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItem.expectations = append(mmDeleteItem.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteItem return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemExpectation) Then(cp1 *model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteItemResults{cp1, err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteItem should be invoked
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Times(n uint64) *mCartRepositoryMockDeleteItem {
	if n == 0 {
		mmDeleteItem.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItem mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItem.expectedInvocations, n)
	mmDeleteItem.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItem
}

func (mmDeleteItem *mCartRepositoryMockDeleteItem) invocationsDone() bool {
	if len(mmDeleteItem.expectations) == 0 && mmDeleteItem.defaultExpectation == nil && mmDeleteItem.mock.funcDeleteItem == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItem.mock.afterDeleteItemCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItem.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItem implements mm_delete_cart.CartRepository
func (mmDeleteItem *CartRepositoryMock) DeleteItem(params model.DeleteCartParameters) (cp1 *model.CartItem, err error) {
	mm_atomic.AddUint64(&mmDeleteItem.beforeDeleteItemCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItem.afterDeleteItemCounter, 1)

	mmDeleteItem.t.Helper()

	if mmDeleteItem.inspectFuncDeleteItem != nil {
		mmDeleteItem.inspectFuncDeleteItem(params)
	}

	mm_params := CartRepositoryMockDeleteItemParams{params}

	// Record call args
	mmDeleteItem.DeleteItemMock.mutex.Lock()
	mmDeleteItem.DeleteItemMock.callArgs = append(mmDeleteItem.DeleteItemMock.callArgs, &mm_params)
	mmDeleteItem.DeleteItemMock.mutex.Unlock()

	for _, e := range mmDeleteItem.DeleteItemMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmDeleteItem.DeleteItemMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItem.DeleteItemMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItem.DeleteItemMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItem.DeleteItemMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteItemParams{params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItem.t.Errorf("CartRepositoryMock.DeleteItem got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItem.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItem.DeleteItemMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItem.t.Fatal("No results are set for the CartRepositoryMock.DeleteItem")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmDeleteItem.funcDeleteItem != nil {
		return mmDeleteItem.funcDeleteItem(params)
	}
	mmDeleteItem.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItem. %v", params)
	return
}

// DeleteItemAfterCounter returns a count of finished CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.afterDeleteItemCounter)
}

// DeleteItemBeforeCounter returns a count of CartRepositoryMock.DeleteItem invocations
func (mmDeleteItem *CartRepositoryMock) DeleteItemBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItem.beforeDeleteItemCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItem.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItem *mCartRepositoryMockDeleteItem) Calls() []*CartRepositoryMockDeleteItemParams {
	mmDeleteItem.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteItemParams, len(mmDeleteItem.callArgs))
	copy(argCopy, mmDeleteItem.callArgs)

	mmDeleteItem.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemDone returns true if the count of the DeleteItem invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemDone() bool {
	if m.DeleteItemMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemMock.invocationsDone()
}

// MinimockDeleteItemInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemInspect() {
	for _, e := range m.DeleteItemMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemCounter := mm_atomic.LoadUint64(&m.afterDeleteItemCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemMock.defaultExpectation != nil && afterDeleteItemCounter < 1 {
		if m.DeleteItemMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s", m.DeleteItemMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s with params: %#v", m.DeleteItemMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItem != nil && afterDeleteItemCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteItem at\n%s", m.funcDeleteItemOrigin)
	}

	if !m.DeleteItemMock.invocationsDone() && afterDeleteItemCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItem at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemMock.expectedInvocations), m.DeleteItemMock.expectedInvocationsOrigin, afterDeleteItemCounter)
	}
}

type mCartRepositoryMockDeleteItemsByUser struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockDeleteItemsByUserExpectation
	expectations       []*CartRepositoryMockDeleteItemsByUserExpectation

	callArgs []*CartRepositoryMockDeleteItemsByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockDeleteItemsByUserExpectation specifies expectation struct of the CartRepository.DeleteItemsByUser
type CartRepositoryMockDeleteItemsByUserExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockDeleteItemsByUserParams
	paramPtrs          *CartRepositoryMockDeleteItemsByUserParamPtrs
	expectationOrigins CartRepositoryMockDeleteItemsByUserExpectationOrigins
	results            *CartRepositoryMockDeleteItemsByUserResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockDeleteItemsByUserParams contains parameters of the CartRepository.DeleteItemsByUser
type CartRepositoryMockDeleteItemsByUserParams struct {
	userId model.UserId
}

// CartRepositoryMockDeleteItemsByUserParamPtrs contains pointers to parameters of the CartRepository.DeleteItemsByUser
type CartRepositoryMockDeleteItemsByUserParamPtrs struct {
	userId *model.UserId
}

// CartRepositoryMockDeleteItemsByUserResults contains results of the CartRepository.DeleteItemsByUser
type CartRepositoryMockDeleteItemsByUserResults struct {
	up1 *model.UserId
	err error
}

// CartRepositoryMockDeleteItemsByUserOrigins contains origins of expectations of the CartRepository.DeleteItemsByUser
type CartRepositoryMockDeleteItemsByUserExpectationOrigins struct {
	origin       string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) Optional() *mCartRepositoryMockDeleteItemsByUser {
	mmDeleteItemsByUser.optional = true
	return mmDeleteItemsByUser
}

// Expect sets up expected params for CartRepository.DeleteItemsByUser
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) Expect(userId model.UserId) *mCartRepositoryMockDeleteItemsByUser {
	if mmDeleteItemsByUser.mock.funcDeleteItemsByUser != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUser mock is already set by Set")
	}

	if mmDeleteItemsByUser.defaultExpectation == nil {
		mmDeleteItemsByUser.defaultExpectation = &CartRepositoryMockDeleteItemsByUserExpectation{}
	}

	if mmDeleteItemsByUser.defaultExpectation.paramPtrs != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUser mock is already set by ExpectParams functions")
	}

	mmDeleteItemsByUser.defaultExpectation.params = &CartRepositoryMockDeleteItemsByUserParams{userId}
	mmDeleteItemsByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteItemsByUser.expectations {
		if minimock.Equal(e.params, mmDeleteItemsByUser.defaultExpectation.params) {
			mmDeleteItemsByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteItemsByUser.defaultExpectation.params)
		}
	}

	return mmDeleteItemsByUser
}

// ExpectUserIdParam1 sets up expected param userId for CartRepository.DeleteItemsByUser
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) ExpectUserIdParam1(userId model.UserId) *mCartRepositoryMockDeleteItemsByUser {
	if mmDeleteItemsByUser.mock.funcDeleteItemsByUser != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUser mock is already set by Set")
	}

	if mmDeleteItemsByUser.defaultExpectation == nil {
		mmDeleteItemsByUser.defaultExpectation = &CartRepositoryMockDeleteItemsByUserExpectation{}
	}

	if mmDeleteItemsByUser.defaultExpectation.params != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUser mock is already set by Expect")
	}

	if mmDeleteItemsByUser.defaultExpectation.paramPtrs == nil {
		mmDeleteItemsByUser.defaultExpectation.paramPtrs = &CartRepositoryMockDeleteItemsByUserParamPtrs{}
	}
	mmDeleteItemsByUser.defaultExpectation.paramPtrs.userId = &userId
	mmDeleteItemsByUser.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmDeleteItemsByUser
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.DeleteItemsByUser
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) Inspect(f func(userId model.UserId)) *mCartRepositoryMockDeleteItemsByUser {
	if mmDeleteItemsByUser.mock.inspectFuncDeleteItemsByUser != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.DeleteItemsByUser")
	}

	mmDeleteItemsByUser.mock.inspectFuncDeleteItemsByUser = f

	return mmDeleteItemsByUser
}

// Return sets up results that will be returned by CartRepository.DeleteItemsByUser
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) Return(up1 *model.UserId, err error) *CartRepositoryMock {
	if mmDeleteItemsByUser.mock.funcDeleteItemsByUser != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUser mock is already set by Set")
	}

	if mmDeleteItemsByUser.defaultExpectation == nil {
		mmDeleteItemsByUser.defaultExpectation = &CartRepositoryMockDeleteItemsByUserExpectation{mock: mmDeleteItemsByUser.mock}
	}
	mmDeleteItemsByUser.defaultExpectation.results = &CartRepositoryMockDeleteItemsByUserResults{up1, err}
	mmDeleteItemsByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUser.mock
}

// Set uses given function f to mock the CartRepository.DeleteItemsByUser method
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) Set(f func(userId model.UserId) (up1 *model.UserId, err error)) *CartRepositoryMock {
	if mmDeleteItemsByUser.defaultExpectation != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("Default expectation is already set for the CartRepository.DeleteItemsByUser method")
	}

	if len(mmDeleteItemsByUser.expectations) > 0 {
		mmDeleteItemsByUser.mock.t.Fatalf("Some expectations are already set for the CartRepository.DeleteItemsByUser method")
	}

	mmDeleteItemsByUser.mock.funcDeleteItemsByUser = f
	mmDeleteItemsByUser.mock.funcDeleteItemsByUserOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUser.mock
}

// When sets expectation for the CartRepository.DeleteItemsByUser which will trigger the result defined by the following
// Then helper
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) When(userId model.UserId) *CartRepositoryMockDeleteItemsByUserExpectation {
	if mmDeleteItemsByUser.mock.funcDeleteItemsByUser != nil {
		mmDeleteItemsByUser.mock.t.Fatalf("CartRepositoryMock.DeleteItemsByUser mock is already set by Set")
	}

	expectation := &CartRepositoryMockDeleteItemsByUserExpectation{
		mock:               mmDeleteItemsByUser.mock,
		params:             &CartRepositoryMockDeleteItemsByUserParams{userId},
		expectationOrigins: CartRepositoryMockDeleteItemsByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteItemsByUser.expectations = append(mmDeleteItemsByUser.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.DeleteItemsByUser return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockDeleteItemsByUserExpectation) Then(up1 *model.UserId, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockDeleteItemsByUserResults{up1, err}
	return e.mock
}

// Times sets number of times CartRepository.DeleteItemsByUser should be invoked
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) Times(n uint64) *mCartRepositoryMockDeleteItemsByUser {
	if n == 0 {
		mmDeleteItemsByUser.mock.t.Fatalf("Times of CartRepositoryMock.DeleteItemsByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteItemsByUser.expectedInvocations, n)
	mmDeleteItemsByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteItemsByUser
}

func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) invocationsDone() bool {
	if len(mmDeleteItemsByUser.expectations) == 0 && mmDeleteItemsByUser.defaultExpectation == nil && mmDeleteItemsByUser.mock.funcDeleteItemsByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUser.mock.afterDeleteItemsByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteItemsByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteItemsByUser implements mm_delete_cart.CartRepository
func (mmDeleteItemsByUser *CartRepositoryMock) DeleteItemsByUser(userId model.UserId) (up1 *model.UserId, err error) {
	mm_atomic.AddUint64(&mmDeleteItemsByUser.beforeDeleteItemsByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteItemsByUser.afterDeleteItemsByUserCounter, 1)

	mmDeleteItemsByUser.t.Helper()

	if mmDeleteItemsByUser.inspectFuncDeleteItemsByUser != nil {
		mmDeleteItemsByUser.inspectFuncDeleteItemsByUser(userId)
	}

	mm_params := CartRepositoryMockDeleteItemsByUserParams{userId}

	// Record call args
	mmDeleteItemsByUser.DeleteItemsByUserMock.mutex.Lock()
	mmDeleteItemsByUser.DeleteItemsByUserMock.callArgs = append(mmDeleteItemsByUser.DeleteItemsByUserMock.callArgs, &mm_params)
	mmDeleteItemsByUser.DeleteItemsByUserMock.mutex.Unlock()

	for _, e := range mmDeleteItemsByUser.DeleteItemsByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmDeleteItemsByUser.DeleteItemsByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteItemsByUser.DeleteItemsByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteItemsByUser.DeleteItemsByUserMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteItemsByUser.DeleteItemsByUserMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockDeleteItemsByUserParams{userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmDeleteItemsByUser.t.Errorf("CartRepositoryMock.DeleteItemsByUser got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteItemsByUser.DeleteItemsByUserMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteItemsByUser.t.Errorf("CartRepositoryMock.DeleteItemsByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteItemsByUser.DeleteItemsByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteItemsByUser.DeleteItemsByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteItemsByUser.t.Fatal("No results are set for the CartRepositoryMock.DeleteItemsByUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmDeleteItemsByUser.funcDeleteItemsByUser != nil {
		return mmDeleteItemsByUser.funcDeleteItemsByUser(userId)
	}
	mmDeleteItemsByUser.t.Fatalf("Unexpected call to CartRepositoryMock.DeleteItemsByUser. %v", userId)
	return
}

// DeleteItemsByUserAfterCounter returns a count of finished CartRepositoryMock.DeleteItemsByUser invocations
func (mmDeleteItemsByUser *CartRepositoryMock) DeleteItemsByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUser.afterDeleteItemsByUserCounter)
}

// DeleteItemsByUserBeforeCounter returns a count of CartRepositoryMock.DeleteItemsByUser invocations
func (mmDeleteItemsByUser *CartRepositoryMock) DeleteItemsByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteItemsByUser.beforeDeleteItemsByUserCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.DeleteItemsByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteItemsByUser *mCartRepositoryMockDeleteItemsByUser) Calls() []*CartRepositoryMockDeleteItemsByUserParams {
	mmDeleteItemsByUser.mutex.RLock()

	argCopy := make([]*CartRepositoryMockDeleteItemsByUserParams, len(mmDeleteItemsByUser.callArgs))
	copy(argCopy, mmDeleteItemsByUser.callArgs)

	mmDeleteItemsByUser.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteItemsByUserDone returns true if the count of the DeleteItemsByUser invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockDeleteItemsByUserDone() bool {
	if m.DeleteItemsByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteItemsByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteItemsByUserMock.invocationsDone()
}

// MinimockDeleteItemsByUserInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockDeleteItemsByUserInspect() {
	for _, e := range m.DeleteItemsByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemsByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteItemsByUserCounter := mm_atomic.LoadUint64(&m.afterDeleteItemsByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteItemsByUserMock.defaultExpectation != nil && afterDeleteItemsByUserCounter < 1 {
		if m.DeleteItemsByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemsByUser at\n%s", m.DeleteItemsByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemsByUser at\n%s with params: %#v", m.DeleteItemsByUserMock.defaultExpectation.expectationOrigins.origin, *m.DeleteItemsByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteItemsByUser != nil && afterDeleteItemsByUserCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.DeleteItemsByUser at\n%s", m.funcDeleteItemsByUserOrigin)
	}

	if !m.DeleteItemsByUserMock.invocationsDone() && afterDeleteItemsByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.DeleteItemsByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteItemsByUserMock.expectedInvocations), m.DeleteItemsByUserMock.expectedInvocationsOrigin, afterDeleteItemsByUserCounter)
	}
}

type mCartRepositoryMockGetItemsByUser struct {
	optional           bool
	mock               *CartRepositoryMock
	defaultExpectation *CartRepositoryMockGetItemsByUserExpectation
	expectations       []*CartRepositoryMockGetItemsByUserExpectation

	callArgs []*CartRepositoryMockGetItemsByUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// CartRepositoryMockGetItemsByUserExpectation specifies expectation struct of the CartRepository.GetItemsByUser
type CartRepositoryMockGetItemsByUserExpectation struct {
	mock               *CartRepositoryMock
	params             *CartRepositoryMockGetItemsByUserParams
	paramPtrs          *CartRepositoryMockGetItemsByUserParamPtrs
	expectationOrigins CartRepositoryMockGetItemsByUserExpectationOrigins
	results            *CartRepositoryMockGetItemsByUserResults
	returnOrigin       string
	Counter            uint64
}

// CartRepositoryMockGetItemsByUserParams contains parameters of the CartRepository.GetItemsByUser
type CartRepositoryMockGetItemsByUserParams struct {
	userId model.UserId
}

// CartRepositoryMockGetItemsByUserParamPtrs contains pointers to parameters of the CartRepository.GetItemsByUser
type CartRepositoryMockGetItemsByUserParamPtrs struct {
	userId *model.UserId
}

// CartRepositoryMockGetItemsByUserResults contains results of the CartRepository.GetItemsByUser
type CartRepositoryMockGetItemsByUserResults struct {
	ca1 []model.CartItem
	err error
}

// CartRepositoryMockGetItemsByUserOrigins contains origins of expectations of the CartRepository.GetItemsByUser
type CartRepositoryMockGetItemsByUserExpectationOrigins struct {
	origin       string
	originUserId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) Optional() *mCartRepositoryMockGetItemsByUser {
	mmGetItemsByUser.optional = true
	return mmGetItemsByUser
}

// Expect sets up expected params for CartRepository.GetItemsByUser
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) Expect(userId model.UserId) *mCartRepositoryMockGetItemsByUser {
	if mmGetItemsByUser.mock.funcGetItemsByUser != nil {
		mmGetItemsByUser.mock.t.Fatalf("CartRepositoryMock.GetItemsByUser mock is already set by Set")
	}

	if mmGetItemsByUser.defaultExpectation == nil {
		mmGetItemsByUser.defaultExpectation = &CartRepositoryMockGetItemsByUserExpectation{}
	}

	if mmGetItemsByUser.defaultExpectation.paramPtrs != nil {
		mmGetItemsByUser.mock.t.Fatalf("CartRepositoryMock.GetItemsByUser mock is already set by ExpectParams functions")
	}

	mmGetItemsByUser.defaultExpectation.params = &CartRepositoryMockGetItemsByUserParams{userId}
	mmGetItemsByUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetItemsByUser.expectations {
		if minimock.Equal(e.params, mmGetItemsByUser.defaultExpectation.params) {
			mmGetItemsByUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetItemsByUser.defaultExpectation.params)
		}
	}

	return mmGetItemsByUser
}

// ExpectUserIdParam1 sets up expected param userId for CartRepository.GetItemsByUser
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) ExpectUserIdParam1(userId model.UserId) *mCartRepositoryMockGetItemsByUser {
	if mmGetItemsByUser.mock.funcGetItemsByUser != nil {
		mmGetItemsByUser.mock.t.Fatalf("CartRepositoryMock.GetItemsByUser mock is already set by Set")
	}

	if mmGetItemsByUser.defaultExpectation == nil {
		mmGetItemsByUser.defaultExpectation = &CartRepositoryMockGetItemsByUserExpectation{}
	}

	if mmGetItemsByUser.defaultExpectation.params != nil {
		mmGetItemsByUser.mock.t.Fatalf("CartRepositoryMock.GetItemsByUser mock is already set by Expect")
	}

	if mmGetItemsByUser.defaultExpectation.paramPtrs == nil {
		mmGetItemsByUser.defaultExpectation.paramPtrs = &CartRepositoryMockGetItemsByUserParamPtrs{}
	}
	mmGetItemsByUser.defaultExpectation.paramPtrs.userId = &userId
	mmGetItemsByUser.defaultExpectation.expectationOrigins.originUserId = minimock.CallerInfo(1)

	return mmGetItemsByUser
}

// Inspect accepts an inspector function that has same arguments as the CartRepository.GetItemsByUser
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) Inspect(f func(userId model.UserId)) *mCartRepositoryMockGetItemsByUser {
	if mmGetItemsByUser.mock.inspectFuncGetItemsByUser != nil {
		mmGetItemsByUser.mock.t.Fatalf("Inspect function is already set for CartRepositoryMock.GetItemsByUser")
	}

	mmGetItemsByUser.mock.inspectFuncGetItemsByUser = f

	return mmGetItemsByUser
}

// Return sets up results that will be returned by CartRepository.GetItemsByUser
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) Return(ca1 []model.CartItem, err error) *CartRepositoryMock {
	if mmGetItemsByUser.mock.funcGetItemsByUser != nil {
		mmGetItemsByUser.mock.t.Fatalf("CartRepositoryMock.GetItemsByUser mock is already set by Set")
	}

	if mmGetItemsByUser.defaultExpectation == nil {
		mmGetItemsByUser.defaultExpectation = &CartRepositoryMockGetItemsByUserExpectation{mock: mmGetItemsByUser.mock}
	}
	mmGetItemsByUser.defaultExpectation.results = &CartRepositoryMockGetItemsByUserResults{ca1, err}
	mmGetItemsByUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUser.mock
}

// Set uses given function f to mock the CartRepository.GetItemsByUser method
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) Set(f func(userId model.UserId) (ca1 []model.CartItem, err error)) *CartRepositoryMock {
	if mmGetItemsByUser.defaultExpectation != nil {
		mmGetItemsByUser.mock.t.Fatalf("Default expectation is already set for the CartRepository.GetItemsByUser method")
	}

	if len(mmGetItemsByUser.expectations) > 0 {
		mmGetItemsByUser.mock.t.Fatalf("Some expectations are already set for the CartRepository.GetItemsByUser method")
	}

	mmGetItemsByUser.mock.funcGetItemsByUser = f
	mmGetItemsByUser.mock.funcGetItemsByUserOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUser.mock
}

// When sets expectation for the CartRepository.GetItemsByUser which will trigger the result defined by the following
// Then helper
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) When(userId model.UserId) *CartRepositoryMockGetItemsByUserExpectation {
	if mmGetItemsByUser.mock.funcGetItemsByUser != nil {
		mmGetItemsByUser.mock.t.Fatalf("CartRepositoryMock.GetItemsByUser mock is already set by Set")
	}

	expectation := &CartRepositoryMockGetItemsByUserExpectation{
		mock:               mmGetItemsByUser.mock,
		params:             &CartRepositoryMockGetItemsByUserParams{userId},
		expectationOrigins: CartRepositoryMockGetItemsByUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetItemsByUser.expectations = append(mmGetItemsByUser.expectations, expectation)
	return expectation
}

// Then sets up CartRepository.GetItemsByUser return parameters for the expectation previously defined by the When method
func (e *CartRepositoryMockGetItemsByUserExpectation) Then(ca1 []model.CartItem, err error) *CartRepositoryMock {
	e.results = &CartRepositoryMockGetItemsByUserResults{ca1, err}
	return e.mock
}

// Times sets number of times CartRepository.GetItemsByUser should be invoked
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) Times(n uint64) *mCartRepositoryMockGetItemsByUser {
	if n == 0 {
		mmGetItemsByUser.mock.t.Fatalf("Times of CartRepositoryMock.GetItemsByUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetItemsByUser.expectedInvocations, n)
	mmGetItemsByUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetItemsByUser
}

func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) invocationsDone() bool {
	if len(mmGetItemsByUser.expectations) == 0 && mmGetItemsByUser.defaultExpectation == nil && mmGetItemsByUser.mock.funcGetItemsByUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetItemsByUser.mock.afterGetItemsByUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetItemsByUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetItemsByUser implements mm_delete_cart.CartRepository
func (mmGetItemsByUser *CartRepositoryMock) GetItemsByUser(userId model.UserId) (ca1 []model.CartItem, err error) {
	mm_atomic.AddUint64(&mmGetItemsByUser.beforeGetItemsByUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetItemsByUser.afterGetItemsByUserCounter, 1)

	mmGetItemsByUser.t.Helper()

	if mmGetItemsByUser.inspectFuncGetItemsByUser != nil {
		mmGetItemsByUser.inspectFuncGetItemsByUser(userId)
	}

	mm_params := CartRepositoryMockGetItemsByUserParams{userId}

	// Record call args
	mmGetItemsByUser.GetItemsByUserMock.mutex.Lock()
	mmGetItemsByUser.GetItemsByUserMock.callArgs = append(mmGetItemsByUser.GetItemsByUserMock.callArgs, &mm_params)
	mmGetItemsByUser.GetItemsByUserMock.mutex.Unlock()

	for _, e := range mmGetItemsByUser.GetItemsByUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ca1, e.results.err
		}
	}

	if mmGetItemsByUser.GetItemsByUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetItemsByUser.GetItemsByUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetItemsByUser.GetItemsByUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetItemsByUser.GetItemsByUserMock.defaultExpectation.paramPtrs

		mm_got := CartRepositoryMockGetItemsByUserParams{userId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.userId != nil && !minimock.Equal(*mm_want_ptrs.userId, mm_got.userId) {
				mmGetItemsByUser.t.Errorf("CartRepositoryMock.GetItemsByUser got unexpected parameter userId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetItemsByUser.GetItemsByUserMock.defaultExpectation.expectationOrigins.originUserId, *mm_want_ptrs.userId, mm_got.userId, minimock.Diff(*mm_want_ptrs.userId, mm_got.userId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetItemsByUser.t.Errorf("CartRepositoryMock.GetItemsByUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetItemsByUser.GetItemsByUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetItemsByUser.GetItemsByUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetItemsByUser.t.Fatal("No results are set for the CartRepositoryMock.GetItemsByUser")
		}
		return (*mm_results).ca1, (*mm_results).err
	}
	if mmGetItemsByUser.funcGetItemsByUser != nil {
		return mmGetItemsByUser.funcGetItemsByUser(userId)
	}
	mmGetItemsByUser.t.Fatalf("Unexpected call to CartRepositoryMock.GetItemsByUser. %v", userId)
	return
}

// GetItemsByUserAfterCounter returns a count of finished CartRepositoryMock.GetItemsByUser invocations
func (mmGetItemsByUser *CartRepositoryMock) GetItemsByUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUser.afterGetItemsByUserCounter)
}

// GetItemsByUserBeforeCounter returns a count of CartRepositoryMock.GetItemsByUser invocations
func (mmGetItemsByUser *CartRepositoryMock) GetItemsByUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetItemsByUser.beforeGetItemsByUserCounter)
}

// Calls returns a list of arguments used in each call to CartRepositoryMock.GetItemsByUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetItemsByUser *mCartRepositoryMockGetItemsByUser) Calls() []*CartRepositoryMockGetItemsByUserParams {
	mmGetItemsByUser.mutex.RLock()

	argCopy := make([]*CartRepositoryMockGetItemsByUserParams, len(mmGetItemsByUser.callArgs))
	copy(argCopy, mmGetItemsByUser.callArgs)

	mmGetItemsByUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetItemsByUserDone returns true if the count of the GetItemsByUser invocations corresponds
// the number of defined expectations
func (m *CartRepositoryMock) MinimockGetItemsByUserDone() bool {
	if m.GetItemsByUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetItemsByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetItemsByUserMock.invocationsDone()
}

// MinimockGetItemsByUserInspect logs each unmet expectation
func (m *CartRepositoryMock) MinimockGetItemsByUserInspect() {
	for _, e := range m.GetItemsByUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItemsByUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetItemsByUserCounter := mm_atomic.LoadUint64(&m.afterGetItemsByUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetItemsByUserMock.defaultExpectation != nil && afterGetItemsByUserCounter < 1 {
		if m.GetItemsByUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItemsByUser at\n%s", m.GetItemsByUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to CartRepositoryMock.GetItemsByUser at\n%s with params: %#v", m.GetItemsByUserMock.defaultExpectation.expectationOrigins.origin, *m.GetItemsByUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetItemsByUser != nil && afterGetItemsByUserCounter < 1 {
		m.t.Errorf("Expected call to CartRepositoryMock.GetItemsByUser at\n%s", m.funcGetItemsByUserOrigin)
	}

	if !m.GetItemsByUserMock.invocationsDone() && afterGetItemsByUserCounter > 0 {
		m.t.Errorf("Expected %d calls to CartRepositoryMock.GetItemsByUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetItemsByUserMock.expectedInvocations), m.GetItemsByUserMock.expectedInvocationsOrigin, afterGetItemsByUserCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *CartRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddItemInspect()

			m.MinimockDeleteItemInspect()

			m.MinimockDeleteItemsByUserInspect()

			m.MinimockGetItemsByUserInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *CartRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *CartRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddItemDone() &&
		m.MinimockDeleteItemDone() &&
		m.MinimockDeleteItemsByUserDone() &&
		m.MinimockGetItemsByUserDone()
}
